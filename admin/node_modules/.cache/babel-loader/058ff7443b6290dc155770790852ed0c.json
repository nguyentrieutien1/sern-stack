{"ast":null,"code":"// Cache implementation based on Erik Rasmussen's `lru-memoize`:\n// https://github.com/erikras/lru-memoize\nfunction createSingletonCache(equals) {\n  var entry;\n  return {\n    get: function get(key) {\n      if (entry && equals(entry.key, key)) {\n        return entry.value;\n      }\n    },\n    put: function put(key, value) {\n      entry = {\n        key: key,\n        value: value\n      };\n    },\n    getValues: function getValues() {\n      return entry ? [entry.value] : [];\n    },\n    clear: function clear() {\n      entry = undefined;\n    }\n  };\n}\n\nfunction createLruCache(maxSize, equals) {\n  var entries = [];\n\n  function get(key) {\n    var cacheIndex = entries.findIndex(function (entry) {\n      return equals(key, entry.key);\n    }); // We found a cached entry\n\n    if (cacheIndex > -1) {\n      var entry = entries[cacheIndex]; // Cached entry not at top of cache, move it to the top\n\n      if (cacheIndex > 0) {\n        entries.splice(cacheIndex, 1);\n        entries.unshift(entry);\n      }\n\n      return entry.value;\n    } // No entry found in cache, return null\n\n\n    return undefined;\n  }\n\n  function put(key, value) {\n    if (!get(key)) {\n      // TODO Is unshift slow?\n      entries.unshift({\n        key: key,\n        value: value\n      });\n\n      if (entries.length > maxSize) {\n        entries.pop();\n      }\n    }\n  }\n\n  function getValues() {\n    return entries.map(function (entry) {\n      return entry.value;\n    });\n  }\n\n  function clear() {\n    entries = [];\n  }\n\n  return {\n    get: get,\n    put: put,\n    getValues: getValues,\n    clear: clear\n  };\n}\n\nexport var defaultEqualityCheck = function defaultEqualityCheck(a, b) {\n  return a === b;\n};\nexport function createCacheKeyComparator(equalityCheck) {\n  return function areArgumentsShallowlyEqual(prev, next) {\n    if (prev === null || next === null || prev.length !== next.length) {\n      return false;\n    } // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.\n\n\n    var length = prev.length;\n\n    for (var i = 0; i < length; i++) {\n      if (!equalityCheck(prev[i], next[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n} // defaultMemoize now supports a configurable cache size with LRU behavior,\n// and optional comparison of the result value with existing values\n\nexport function defaultMemoize(func, equalityCheckOrOptions) {\n  var providedOptions = typeof equalityCheckOrOptions === 'object' ? equalityCheckOrOptions : {\n    equalityCheck: equalityCheckOrOptions\n  };\n  var _providedOptions$equa = providedOptions.equalityCheck,\n      equalityCheck = _providedOptions$equa === void 0 ? defaultEqualityCheck : _providedOptions$equa,\n      _providedOptions$maxS = providedOptions.maxSize,\n      maxSize = _providedOptions$maxS === void 0 ? 1 : _providedOptions$maxS,\n      resultEqualityCheck = providedOptions.resultEqualityCheck;\n  var comparator = createCacheKeyComparator(equalityCheck);\n  var cache = maxSize === 1 ? createSingletonCache(comparator) : createLruCache(maxSize, comparator); // we reference arguments instead of spreading them for performance reasons\n\n  function memoized() {\n    var value = cache.get(arguments);\n\n    if (value === undefined) {\n      // @ts-ignore\n      value = func.apply(null, arguments);\n\n      if (resultEqualityCheck) {\n        var existingValues = cache.getValues();\n        var matchingValue = existingValues.find(function (ev) {\n          return resultEqualityCheck(ev, value);\n        });\n\n        if (matchingValue !== undefined) {\n          return matchingValue;\n        }\n      }\n\n      cache.put(arguments, value);\n    }\n\n    return value;\n  }\n\n  memoized.clearCache = function () {\n    return cache.clear();\n  };\n\n  return memoized;\n}","map":{"version":3,"sources":["D:/LearnFullstack/admin/node_modules/reselect/es/defaultMemoize.js"],"names":["createSingletonCache","equals","entry","get","key","value","put","getValues","clear","undefined","createLruCache","maxSize","entries","cacheIndex","findIndex","splice","unshift","length","pop","map","defaultEqualityCheck","a","b","createCacheKeyComparator","equalityCheck","areArgumentsShallowlyEqual","prev","next","i","defaultMemoize","func","equalityCheckOrOptions","providedOptions","_providedOptions$equa","_providedOptions$maxS","resultEqualityCheck","comparator","cache","memoized","arguments","apply","existingValues","matchingValue","find","ev","clearCache"],"mappings":"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","sourcesContent":["// Cache implementation based on Erik Rasmussen's `lru-memoize`:\n// https://github.com/erikras/lru-memoize\nfunction createSingletonCache(equals) {\n  var entry;\n  return {\n    get: function get(key) {\n      if (entry && equals(entry.key, key)) {\n        return entry.value;\n      }\n    },\n    put: function put(key, value) {\n      entry = {\n        key: key,\n        value: value\n      };\n    },\n    getValues: function getValues() {\n      return entry ? [entry.value] : [];\n    },\n    clear: function clear() {\n      entry = undefined;\n    }\n  };\n}\n\nfunction createLruCache(maxSize, equals) {\n  var entries = [];\n\n  function get(key) {\n    var cacheIndex = entries.findIndex(function (entry) {\n      return equals(key, entry.key);\n    }); // We found a cached entry\n\n    if (cacheIndex > -1) {\n      var entry = entries[cacheIndex]; // Cached entry not at top of cache, move it to the top\n\n      if (cacheIndex > 0) {\n        entries.splice(cacheIndex, 1);\n        entries.unshift(entry);\n      }\n\n      return entry.value;\n    } // No entry found in cache, return null\n\n\n    return undefined;\n  }\n\n  function put(key, value) {\n    if (!get(key)) {\n      // TODO Is unshift slow?\n      entries.unshift({\n        key: key,\n        value: value\n      });\n\n      if (entries.length > maxSize) {\n        entries.pop();\n      }\n    }\n  }\n\n  function getValues() {\n    return entries.map(function (entry) {\n      return entry.value;\n    });\n  }\n\n  function clear() {\n    entries = [];\n  }\n\n  return {\n    get: get,\n    put: put,\n    getValues: getValues,\n    clear: clear\n  };\n}\n\nexport var defaultEqualityCheck = function defaultEqualityCheck(a, b) {\n  return a === b;\n};\nexport function createCacheKeyComparator(equalityCheck) {\n  return function areArgumentsShallowlyEqual(prev, next) {\n    if (prev === null || next === null || prev.length !== next.length) {\n      return false;\n    } // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.\n\n\n    var length = prev.length;\n\n    for (var i = 0; i < length; i++) {\n      if (!equalityCheck(prev[i], next[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n}\n// defaultMemoize now supports a configurable cache size with LRU behavior,\n// and optional comparison of the result value with existing values\nexport function defaultMemoize(func, equalityCheckOrOptions) {\n  var providedOptions = typeof equalityCheckOrOptions === 'object' ? equalityCheckOrOptions : {\n    equalityCheck: equalityCheckOrOptions\n  };\n  var _providedOptions$equa = providedOptions.equalityCheck,\n      equalityCheck = _providedOptions$equa === void 0 ? defaultEqualityCheck : _providedOptions$equa,\n      _providedOptions$maxS = providedOptions.maxSize,\n      maxSize = _providedOptions$maxS === void 0 ? 1 : _providedOptions$maxS,\n      resultEqualityCheck = providedOptions.resultEqualityCheck;\n  var comparator = createCacheKeyComparator(equalityCheck);\n  var cache = maxSize === 1 ? createSingletonCache(comparator) : createLruCache(maxSize, comparator); // we reference arguments instead of spreading them for performance reasons\n\n  function memoized() {\n    var value = cache.get(arguments);\n\n    if (value === undefined) {\n      // @ts-ignore\n      value = func.apply(null, arguments);\n\n      if (resultEqualityCheck) {\n        var existingValues = cache.getValues();\n        var matchingValue = existingValues.find(function (ev) {\n          return resultEqualityCheck(ev, value);\n        });\n\n        if (matchingValue !== undefined) {\n          return matchingValue;\n        }\n      }\n\n      cache.put(arguments, value);\n    }\n\n    return value;\n  }\n\n  memoized.clearCache = function () {\n    return cache.clear();\n  };\n\n  return memoized;\n}"]},"metadata":{},"sourceType":"module"}